export concept IsComplex<T> {
  fn real: () -> T;
  fn img: () -> T;

  fn real: (val: T) -> Void;
  fn img: (val: T) -> Void;

  fn +: (other: Complex) -> Complex;
  fn ==: (other: Complex) -> Bool;

  fn conjugate: () -> Complex;
  fn magnitude: () -> Float;
}

export class Complex<T> satisfies IsComplex<T> {
  let mutable real: T;
  let mutable img: T;

  fn real: () -> {}
  fn img: () -> {}

  fn real: (val: T) -> {}
  fn img: (val: T) -> {}

  fn self: (r: T, i: T) -> {
    r |> self.real;
    i |> self.img;
  }

  fn self: () -> String {
    return match {
      self.img < 0 => "{self.real} - {math::abs(self.img)}i",
      _ => "{self.real} + {self.img}i",
    }
  }

  fn +: (other: Complex) -> Complex {
    return {real: self.real + other.real, img: self.img + other.img};
  }

  fn ==: (other: Complex) -> Bool {
    return self.real == other.real && self.img == other.img;
  }

  fn conjugate: () -> Complex {
    return {real: self.real, img: -self.img};
  }

  fn magnitude: () -> Float {
    return math::sqrt((self.real * self.real + self.img * self.img) |> Float);
  }
}